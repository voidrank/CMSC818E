// Code generated by protoc-gen-go. DO NOT EDIT.
// source: lock.proto

package pbl

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type LockType int32

const (
	LockType_SHARED    LockType = 0
	LockType_EXCLUSIVE LockType = 1
)

var LockType_name = map[int32]string{
	0: "SHARED",
	1: "EXCLUSIVE",
}

var LockType_value = map[string]int32{
	"SHARED":    0,
	"EXCLUSIVE": 1,
}

func (x LockType) String() string {
	return proto.EnumName(LockType_name, int32(x))
}

func (LockType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_164ad2988c7acaf1, []int{0}
}

type LockAcquireRequest struct {
	Path                 string   `protobuf:"bytes,1,opt,name=Path,proto3" json:"Path,omitempty"`
	Mode                 LockType `protobuf:"varint,2,opt,name=Mode,proto3,enum=pbl.LockType" json:"Mode,omitempty"`
	RepID                int64    `protobuf:"varint,3,opt,name=RepID,proto3" json:"RepID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LockAcquireRequest) Reset()         { *m = LockAcquireRequest{} }
func (m *LockAcquireRequest) String() string { return proto.CompactTextString(m) }
func (*LockAcquireRequest) ProtoMessage()    {}
func (*LockAcquireRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_164ad2988c7acaf1, []int{0}
}

func (m *LockAcquireRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LockAcquireRequest.Unmarshal(m, b)
}
func (m *LockAcquireRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LockAcquireRequest.Marshal(b, m, deterministic)
}
func (m *LockAcquireRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LockAcquireRequest.Merge(m, src)
}
func (m *LockAcquireRequest) XXX_Size() int {
	return xxx_messageInfo_LockAcquireRequest.Size(m)
}
func (m *LockAcquireRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LockAcquireRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LockAcquireRequest proto.InternalMessageInfo

func (m *LockAcquireRequest) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *LockAcquireRequest) GetMode() LockType {
	if m != nil {
		return m.Mode
	}
	return LockType_SHARED
}

func (m *LockAcquireRequest) GetRepID() int64 {
	if m != nil {
		return m.RepID
	}
	return 0
}

type LockAcquireReply struct {
	Path                 string   `protobuf:"bytes,1,opt,name=Path,proto3" json:"Path,omitempty"`
	Mode                 LockType `protobuf:"varint,2,opt,name=Mode,proto3,enum=pbl.LockType" json:"Mode,omitempty"`
	RepID                int64    `protobuf:"varint,3,opt,name=RepID,proto3" json:"RepID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LockAcquireReply) Reset()         { *m = LockAcquireReply{} }
func (m *LockAcquireReply) String() string { return proto.CompactTextString(m) }
func (*LockAcquireReply) ProtoMessage()    {}
func (*LockAcquireReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_164ad2988c7acaf1, []int{1}
}

func (m *LockAcquireReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LockAcquireReply.Unmarshal(m, b)
}
func (m *LockAcquireReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LockAcquireReply.Marshal(b, m, deterministic)
}
func (m *LockAcquireReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LockAcquireReply.Merge(m, src)
}
func (m *LockAcquireReply) XXX_Size() int {
	return xxx_messageInfo_LockAcquireReply.Size(m)
}
func (m *LockAcquireReply) XXX_DiscardUnknown() {
	xxx_messageInfo_LockAcquireReply.DiscardUnknown(m)
}

var xxx_messageInfo_LockAcquireReply proto.InternalMessageInfo

func (m *LockAcquireReply) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *LockAcquireReply) GetMode() LockType {
	if m != nil {
		return m.Mode
	}
	return LockType_SHARED
}

func (m *LockAcquireReply) GetRepID() int64 {
	if m != nil {
		return m.RepID
	}
	return 0
}

type LockReleaseRequest struct {
	Path                 string   `protobuf:"bytes,1,opt,name=Path,proto3" json:"Path,omitempty"`
	Mode                 LockType `protobuf:"varint,2,opt,name=Mode,proto3,enum=pbl.LockType" json:"Mode,omitempty"`
	RepID                int64    `protobuf:"varint,3,opt,name=RepID,proto3" json:"RepID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LockReleaseRequest) Reset()         { *m = LockReleaseRequest{} }
func (m *LockReleaseRequest) String() string { return proto.CompactTextString(m) }
func (*LockReleaseRequest) ProtoMessage()    {}
func (*LockReleaseRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_164ad2988c7acaf1, []int{2}
}

func (m *LockReleaseRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LockReleaseRequest.Unmarshal(m, b)
}
func (m *LockReleaseRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LockReleaseRequest.Marshal(b, m, deterministic)
}
func (m *LockReleaseRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LockReleaseRequest.Merge(m, src)
}
func (m *LockReleaseRequest) XXX_Size() int {
	return xxx_messageInfo_LockReleaseRequest.Size(m)
}
func (m *LockReleaseRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LockReleaseRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LockReleaseRequest proto.InternalMessageInfo

func (m *LockReleaseRequest) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *LockReleaseRequest) GetMode() LockType {
	if m != nil {
		return m.Mode
	}
	return LockType_SHARED
}

func (m *LockReleaseRequest) GetRepID() int64 {
	if m != nil {
		return m.RepID
	}
	return 0
}

type LockReleaseReply struct {
	Path                 string   `protobuf:"bytes,1,opt,name=Path,proto3" json:"Path,omitempty"`
	Mode                 LockType `protobuf:"varint,2,opt,name=Mode,proto3,enum=pbl.LockType" json:"Mode,omitempty"`
	RepID                int64    `protobuf:"varint,3,opt,name=RepID,proto3" json:"RepID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LockReleaseReply) Reset()         { *m = LockReleaseReply{} }
func (m *LockReleaseReply) String() string { return proto.CompactTextString(m) }
func (*LockReleaseReply) ProtoMessage()    {}
func (*LockReleaseReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_164ad2988c7acaf1, []int{3}
}

func (m *LockReleaseReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LockReleaseReply.Unmarshal(m, b)
}
func (m *LockReleaseReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LockReleaseReply.Marshal(b, m, deterministic)
}
func (m *LockReleaseReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LockReleaseReply.Merge(m, src)
}
func (m *LockReleaseReply) XXX_Size() int {
	return xxx_messageInfo_LockReleaseReply.Size(m)
}
func (m *LockReleaseReply) XXX_DiscardUnknown() {
	xxx_messageInfo_LockReleaseReply.DiscardUnknown(m)
}

var xxx_messageInfo_LockReleaseReply proto.InternalMessageInfo

func (m *LockReleaseReply) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *LockReleaseReply) GetMode() LockType {
	if m != nil {
		return m.Mode
	}
	return LockType_SHARED
}

func (m *LockReleaseReply) GetRepID() int64 {
	if m != nil {
		return m.RepID
	}
	return 0
}

func init() {
	proto.RegisterEnum("pbl.LockType", LockType_name, LockType_value)
	proto.RegisterType((*LockAcquireRequest)(nil), "pbl.LockAcquireRequest")
	proto.RegisterType((*LockAcquireReply)(nil), "pbl.LockAcquireReply")
	proto.RegisterType((*LockReleaseRequest)(nil), "pbl.LockReleaseRequest")
	proto.RegisterType((*LockReleaseReply)(nil), "pbl.LockReleaseReply")
}

func init() { proto.RegisterFile("lock.proto", fileDescriptor_164ad2988c7acaf1) }

var fileDescriptor_164ad2988c7acaf1 = []byte{
	// 238 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0xe2, 0xca, 0xc9, 0x4f, 0xce,
	0xd6, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0x62, 0x2e, 0x48, 0xca, 0x51, 0x4a, 0xe4, 0x12, 0xf2,
	0xc9, 0x4f, 0xce, 0x76, 0x4c, 0x2e, 0x2c, 0xcd, 0x2c, 0x4a, 0x0d, 0x4a, 0x2d, 0x2c, 0x4d, 0x2d,
	0x2e, 0x11, 0x12, 0xe2, 0x62, 0x09, 0x48, 0x2c, 0xc9, 0x90, 0x60, 0x54, 0x60, 0xd4, 0xe0, 0x0c,
	0x02, 0xb3, 0x85, 0x14, 0xb9, 0x58, 0x7c, 0xf3, 0x53, 0x52, 0x25, 0x98, 0x14, 0x18, 0x35, 0xf8,
	0x8c, 0x78, 0xf5, 0x0a, 0x92, 0x72, 0xf4, 0x40, 0x5a, 0x43, 0x2a, 0x0b, 0x52, 0x83, 0xc0, 0x52,
	0x42, 0x22, 0x5c, 0xac, 0x41, 0xa9, 0x05, 0x9e, 0x2e, 0x12, 0xcc, 0x0a, 0x8c, 0x1a, 0xcc, 0x41,
	0x10, 0x8e, 0x52, 0x3c, 0x97, 0x00, 0x8a, 0x15, 0x05, 0x39, 0x95, 0xd4, 0xb5, 0x00, 0xea, 0x87,
	0xa0, 0xd4, 0x9c, 0xd4, 0xc4, 0x62, 0x9a, 0xfa, 0x01, 0x6e, 0x05, 0xb5, 0xfd, 0xa0, 0xa5, 0xca,
	0xc5, 0x01, 0x53, 0x27, 0xc4, 0xc5, 0xc5, 0x16, 0xec, 0xe1, 0x18, 0xe4, 0xea, 0x22, 0xc0, 0x20,
	0xc4, 0xcb, 0xc5, 0xe9, 0x1a, 0xe1, 0xec, 0x13, 0x1a, 0xec, 0x19, 0xe6, 0x2a, 0xc0, 0x68, 0xd4,
	0xc0, 0xc8, 0xc5, 0x02, 0x52, 0x27, 0x64, 0xcd, 0xc5, 0x0e, 0x0d, 0x50, 0x21, 0x71, 0xb8, 0x2d,
	0xa8, 0xb1, 0x28, 0x25, 0x8a, 0x29, 0x51, 0x90, 0x53, 0xa9, 0xc4, 0x00, 0xd2, 0x0c, 0xf5, 0x09,
	0x92, 0x66, 0xd4, 0xe0, 0x43, 0xd2, 0x8c, 0xec, 0x69, 0x25, 0x86, 0x24, 0x36, 0x70, 0xea, 0x31,
	0x06, 0x04, 0x00, 0x00, 0xff, 0xff, 0x51, 0xa2, 0x08, 0xf4, 0x4b, 0x02, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// LockClient is the client API for Lock service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type LockClient interface {
	Acquire(ctx context.Context, in *LockAcquireRequest, opts ...grpc.CallOption) (*LockAcquireReply, error)
	Release(ctx context.Context, in *LockReleaseRequest, opts ...grpc.CallOption) (*LockReleaseReply, error)
}

type lockClient struct {
	cc *grpc.ClientConn
}

func NewLockClient(cc *grpc.ClientConn) LockClient {
	return &lockClient{cc}
}

func (c *lockClient) Acquire(ctx context.Context, in *LockAcquireRequest, opts ...grpc.CallOption) (*LockAcquireReply, error) {
	out := new(LockAcquireReply)
	err := c.cc.Invoke(ctx, "/pbl.Lock/Acquire", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lockClient) Release(ctx context.Context, in *LockReleaseRequest, opts ...grpc.CallOption) (*LockReleaseReply, error) {
	out := new(LockReleaseReply)
	err := c.cc.Invoke(ctx, "/pbl.Lock/Release", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LockServer is the server API for Lock service.
type LockServer interface {
	Acquire(context.Context, *LockAcquireRequest) (*LockAcquireReply, error)
	Release(context.Context, *LockReleaseRequest) (*LockReleaseReply, error)
}

func RegisterLockServer(s *grpc.Server, srv LockServer) {
	s.RegisterService(&_Lock_serviceDesc, srv)
}

func _Lock_Acquire_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LockAcquireRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LockServer).Acquire(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pbl.Lock/Acquire",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LockServer).Acquire(ctx, req.(*LockAcquireRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lock_Release_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LockReleaseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LockServer).Release(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pbl.Lock/Release",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LockServer).Release(ctx, req.(*LockReleaseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Lock_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pbl.Lock",
	HandlerType: (*LockServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Acquire",
			Handler:    _Lock_Acquire_Handler,
		},
		{
			MethodName: "Release",
			Handler:    _Lock_Release_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "lock.proto",
}
